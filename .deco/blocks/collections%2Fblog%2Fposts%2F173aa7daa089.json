{
  "name": "collections/blog/posts/173aa7daa089",
  "__resolveType": "blog/loaders/Blogpost.ts",
  "post": {
    "authors": [
      {
        "name": "Marcos Candeia",
        "email": "marcoscandeia123@gmail.com",
        "jobTitle": "Software Engineer",
        "company": "deco.cx",
        "avatar": "https://ozksgdmyrqcxcwhnbepg.supabase.co/storage/v1/object/public/assets/1527/7286de42-e9c5-4fcb-ae8b-b992eea4b78e"
      }
    ],
    "categories": [
      {
        "name": "Tech",
        "slug": "tech"
      }
    ],
    "content": "<h2>First of all, hello readers!</h2><p></p><p>I'm Marcos Candeia, a 30-year-old software developer with ~11 years of experience (8 professionally). My primary playground is the web, where I craft services and solutions. I'm an open-source contributor, and currently, I'm part of the dynamic team at deco üêÅ, which has inspired me to write this blog post using their tech stack.</p><p></p><p>Today I want to talk about how I have implemented my own version of ngrok and how we use it at <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://deco.cx\">deco.cx</a>.</p><p></p><h2>What is Warp?</h2><p></p><p>Warp is a tool that makes your <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://localhost\">localhost</a> available through the web, similar to ngrok. However, it offers some unique advantages that can significantly enhance your development workflow.</p><p>Unlike traditional <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://localhost\">localhost</a> environments, Warp integrates seamlessly with CDN (Content Delivery Network) services. This integration provides several benefits that make your development environment more \"productive\":</p><ol><li><p><strong>Image Transformation (based on the device):</strong> Automatically adjusts images based on the device type, ensuring optimal display and performance across different devices.</p></li><li><p><strong>Image Compression and Optimization (e.g., AVIF):</strong> Reduces image sizes and optimizes them for faster loading times without compromising quality.</p></li><li><p><strong>Asset Caching:</strong> Improves load times and reduces server load by caching static assets.</p></li></ol><p></p><p>With these advantages, you can track performance issues early on and potentially achieve better theoretical performance than running the application solely on your local machine, even considering the overhead of proxying through localhost. At <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://deco.cx\">deco.cx</a>, we use Warp to make your localhost accessible through our admin interface. This allows us to change files directly in the file system, making it the single source of truth for the state of your site. For example, I didn't write a single line of code to publish this blog; it was all managed through our admin.</p><p></p><h2>Summary: Why Making Your Localhost Available Through the Web is Important</h2><p></p><p>1. <strong>Share Your Work Easily:</strong> By making your local environment available on the web, you can easily share your work with colleagues, clients, or anyone else without needing to deploy it publicly. This is particularly useful for getting feedback early in the development process.</p><p>2. <strong>Test Real-world Scenarios:</strong> Testing your application in a real-world environment helps catch issues that might not be apparent in a local setup. By using Warp, you can ensure your application works as expected when accessed over the internet.</p><p>3. <strong>Leverage CDN Benefits:</strong> As mentioned, using Warp allows you to take advantage of CDN features like image transformation, compression, and caching, making your development process more efficient and your application faster.</p><p></p><h2>Show me the code</h2><p></p><h3>Data Handling in Multiple Directions</h3><p>One of the main challenges was handling data in multiple directions. The request body and response body are both streams, which means they can be streamed simultaneously. For example, consider an \"echo\" server that streams the request forward to the server and the server streams it back to the client. To avoid memory overhead and improve performance, I decided to transfer chunks of data instead of buffering the entire body in memory.</p><p><img src=\"https://ozksgdmyrqcxcwhnbepg.supabase.co/storage/v1/object/public/assets/10567/2ef85f81-362d-4c4e-a673-87f37bfac971\"></p><h3>Managing WebSocket Callbacks</h3><p>Another challenge was dealing with WebSocket methods, which often use function callbacks. Although I love JavaScript/TypeScript, I dislike callbacks. Drawing from my experience with Go, which handles concurrency elegantly with channels, I created abstractions to transform WebSockets and streams into channels, allowing me to compose them together.</p><p></p><p>Here is an implementation of a generic channel,</p><p></p><pre><code>export const makeChan = &lt;T&gt;(): Channel&lt;T&gt; =&gt; {\n    const queue: Queue&lt;{ value: T, resolve: () =&gt; void }&gt; = new Queue();\n    const ctrl = new AbortController();\n    const abortPromise = Promise.withResolvers&lt;void&gt;();\n    ctrl.signal.onabort = () =&gt; {\n        abortPromise.resolve();\n    }\n\n    const send = (value: T): Promise&lt;void&gt; =&gt; {\n        return new Promise((resolve, reject) =&gt; {\n            if (ctrl.signal.aborted) reject(new ClosedChannelError());\n            queue.push({ value, resolve });\n        });\n    };\n\n    const close = () =&gt; {\n        ctrl.abort();\n    };\n\n    const recv = async function* (signal?: AbortSignal): AsyncIterableIterator&lt;T&gt; {\n        const linked = signal ? link(ctrl.signal, signal) : ctrl.signal;\n        while (true) {\n            if (linked.aborted) {\n                return;\n            }\n            try {\n                const next = await queue.pop({ signal: linked });\n                next.resolve();\n                yield next.value;\n            } catch (_err) {\n                if (linked.aborted) {\n                    return;\n                }\n                throw _err;\n            }\n        }\n    };\n\n    return { send, recv, close, signal: ctrl.signal, closed: abortPromise.promise };\n\n};\n</code></pre><p></p><p>One of the most interesting aspects of the JavaScript channel implementation is its similarity to Go channels, particularly when using <code>AsyncIterableIterators</code>. The concept is the same: you can use a <code>for-loop</code><em> </em>to iterate over the channel and wait for the iterator to close, at which point the loop ends. This mirrors the functionality of a Go channel but leverages JavaScript's generators. You can read more about generators <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator\">here</a>.</p><p></p><p>For the WebSocket implementation, I created two channels: one for receiving messages and one for sending messages. This approach allows for different kinds of messages to be transmitted with the strong typing provided by TypeScript.</p><p></p><pre><code>\n    const hosts: string[] = [];\n    const state: ServerConnectionState = {\n        clientId,\n        socket,\n        ch,\n        controller: {\n          link: (host) =&gt; {\n            hosts.push(host);\n            hostToClientId[host] = clientId;\n          },\n        },\n        ongoingRequests: {},\n        apiKeys,\n      };\n      serverStates[state.clientId] = state;\n      \n      try {\n        for await (const message of ch.in.recv(req.signal)) {\n          await handleClientMessage(state, message);\n        }\n      } catch (_err) {\n        // ignore\n      } finally {\n        delete serverStates[clientId];\n        for (const host of hosts) {\n          if (hostToClientId[host] === clientId) {\n            delete hostToClientId[host];\n          }\n        }\n      }\n      </code></pre><p></p><p>These are the steps.</p><p>1. <strong>Server State Initialization:</strong></p><p>- A list of <code>hosts</code> and a <code>ServerConnectionState</code> object <code>state</code> are initialized.</p><p>- The <code>controller</code> has a <code>link</code> method that adds hosts to the list and maps them to the <code>clientId</code>.</p><p>2. <strong>Handling Incoming Messages:</strong></p><p>- The <code>serverStates</code> global object is updated with the new <code>state</code>.</p><p>- A <code>try</code> block listens for messages from the channel and processes them with <code>handleClientMessage</code>.</p><p>3. <strong>Cleanup:</strong></p><p>- When the connection ends, the <code>finally</code> block deletes the <code>serverStates</code> entry for the <code>clientId</code>.</p><p>- It then iterates over the <code>hosts</code> list and removes any mappings from <code>hostToClientId</code> that match the <code>clientId</code>.</p><p>By implementing this approach, I ensured efficient memory management and prevented potential race conditions, maintaining a stable and reliable system.</p><p></p><h2>Conclusion</h2><p>Creating Warp involved overcoming several challenges related to data handling, WebSocket management, and state machine implementation. By leveraging channels and state machines, I was able to create an efficient and robust solution. This implementation allows developers to expose their localhost environments through the web, enabling collaboration and testing in a production-like environment with CDN benefits such as image transformation, compression, and asset caching.</p><p>I hope this post helps you understand the importance of making your local environment available through the web and inspires you to create your own tools.</p><p></p><p>The code is fully open-source and can be found <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/deco-cx/warp\">here</a>. Also you can learn how to use warp from <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://deno.com/blog/jsr_open_beta\">JSR</a> - a new global javascript registry that serves for multiple javascript runtimes.</p><p></p><p><strong><span style=\"color: rgb(0, 0, 0)\">Check out how to use this in your personal projects at </span></strong><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://jsr.io\"><strong><span style=\"color: rgb(0, 0, 0)\">jsr.io</span></strong></a><span style=\"color: rgb(236, 236, 236)\">: </span><a target=\"_new\" rel=\"noreferrer\" href=\"https://jsr.io/@deco/warp\">Warp on JSR</a><span style=\"color: rgb(236, 236, 236)\">.</span></p><p></p><p>And see you around,</p><p></p><p>Bye!</p><p></p><p></p>",
    "slug": "warp",
    "excerpt": "Warp is a simple tool that allows your locally running HTTP(s) servers to have a public URL, serving as an easy-to-self-host alternative to services like ngrok",
    "title": "How to Make Your Localhost Available Through the Web and Why This Is Important",
    "image": "https://ozksgdmyrqcxcwhnbepg.supabase.co/storage/v1/object/public/assets/10567/ff737e8e-7356-4dc3-843a-93a9a4338b66",
    "date": "2024-05-29"
  }
}