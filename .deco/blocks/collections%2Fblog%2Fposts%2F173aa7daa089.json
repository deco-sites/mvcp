{
  "name": "collections/blog/posts/173aa7daa089",
  "__resolveType": "blog/loaders/Blogpost.ts",
  "post": {
    "authors": [
      {
        "name": "Marcos Candeia",
        "email": "marcoscandeia123@gmail.com",
        "jobTitle": "Software Engineer",
        "company": "deco.cx",
        "avatar": "https://ozksgdmyrqcxcwhnbepg.supabase.co/storage/v1/object/public/assets/1527/7286de42-e9c5-4fcb-ae8b-b992eea4b78e"
      }
    ],
    "categories": [
      {
        "name": "Tech",
        "slug": "tech"
      }
    ],
    "content": "<h2>First of all, hello readers!</h2>\n<p></p>\n<p>\n  I'm Marcos Candeia, a 30-year-old software developer with ~11 years of\n  experience (8 professionally). My primary playground is the web, where I craft\n  services and solutions. I'm an open-source contributor, and currently, I'm\n  part of the dynamic team at deco üêÅ, which has inspired me to write this blog\n  post using their tech stack.\n</p>\n<p></p>\n<p>\n  Today I want to talk about how I have implemented my own version of ngrok and\n  how we use it at\n  <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://deco.cx\"\n    >deco.cx</a\n  >.\n</p>\n<p></p>\n<h2>What is Warp?</h2>\n<p></p>\n<p>\n  Warp is a tool that makes your localhost available through the web, similar to\n  ngrok. However, it offers some unique advantages that can significantly\n  enhance your development workflow.\n</p>\n<p></p>\n<p>\n  Unlike traditional localhost environments, Warp integrates seamlessly with CDN\n  (Content Delivery Network) services. This integration provides several\n  benefits that make your development environment more \"productive\":\n</p>\n<p></p>\n<p>\n  1. <strong>Image Transformation (based on the device):</strong> Automatically\n  adjusts images based on the device type, ensuring optimal display and\n  performance across different devices.\n</p>\n<p>\n  2. <strong>Image Compression and Optimization (e.g., AVIF):</strong> Reduces\n  image sizes and optimizes them for faster loading times without compromising\n  quality.\n</p>\n<p>\n  3. <strong>Asset Caching:</strong> Improves load times and reduces server load\n  by caching static assets.\n</p>\n<p></p>\n<h2>Why Making Your Localhost Available Through the Web is Important</h2>\n<p></p>\n<p>\n  1. <strong>Share Your Work Easily:</strong> By making your local environment\n  available on the web, you can easily share your work with colleagues, clients,\n  or anyone else without needing to deploy it publicly. This is particularly\n  useful for getting feedback early in the development process.\n</p>\n<p>\n  2. <strong>Test Real-world Scenarios:</strong> Testing your application in a\n  real-world environment helps catch issues that might not be apparent in a\n  local setup. By using Warp, you can ensure your application works as expected\n  when accessed over the internet.\n</p>\n<p>\n  3. <strong>Leverage CDN Benefits:</strong> As mentioned, using Warp allows you\n  to take advantage of CDN features like image transformation, compression, and\n  caching, making your development process more efficient and your application\n  faster.\n</p>\n<p></p>\n<h2>Show me the code</h2>\n<p></p>\n<h3>Data Handling in Multiple Directions</h3>\n<p>\n  One of the main challenges was handling data in multiple directions. The\n  request body and response body are both streams, which means they can be\n  streamed simultaneously. For example, consider an \"echo\" server that streams\n  the request forward to the server and the server streams it back to the\n  client. To avoid memory overhead and improve performance, I decided to\n  transfer chunks of data instead of buffering the entire body in memory.\n</p>\n<p>\n  <img\n    src=\"https://ozksgdmyrqcxcwhnbepg.supabase.co/storage/v1/object/public/assets/10567/2ef85f81-362d-4c4e-a673-87f37bfac971\"\n  />\n</p>\n<h3>Managing WebSocket Callbacks</h3>\n<p>\n  Another challenge was dealing with WebSocket methods, which often use function\n  callbacks. Although I love JavaScript/TypeScript, I dislike callbacks. Drawing\n  from my experience with Go, which handles concurrency elegantly with channels,\n  I created abstractions to transform WebSockets and streams into channels,\n  allowing me to compose them together.\n</p>\n<p></p>\n<p>Here is an implementation of a generic channel,</p>\n<p></p>\n<!-- HTML generated using hilite.me --><div style=\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.0em .0em .0em .0em;padding:.2em .6em;\"><pre style=\"margin: 0; line-height: 125%\"><span style=\"color: #0000ff\">export</span> <span style=\"color: #0000ff\">const</span> makeChan = &lt;T&gt;(): Channel&lt;T&gt; =&gt; {\n    <span style=\"color: #0000ff\">const</span> queue: <span style=\"color: #2b91af\">Queue</span>&lt;{ value: <span style=\"color: #2b91af\">T</span>, resolve: () =&gt; <span style=\"color: #0000ff\">void</span> }&gt; = <span style=\"color: #0000ff\">new</span> Queue();\n    <span style=\"color: #0000ff\">const</span> ctrl = <span style=\"color: #0000ff\">new</span> AbortController();\n    <span style=\"color: #0000ff\">const</span> abortPromise = Promise.withResolvers&lt;<span style=\"color: #0000ff\">void</span>&gt;();\n    ctrl.signal.onabort = () =&gt; {\n        abortPromise.resolve();\n    }\n\n    <span style=\"color: #0000ff\">const</span> send = (value: <span style=\"color: #2b91af\">T</span>): Promise&lt;<span style=\"color: #0000ff\">void</span>&gt; =&gt; {\n        <span style=\"color: #0000ff\">return</span> <span style=\"color: #0000ff\">new</span> Promise((resolve, reject) =&gt; {\n            <span style=\"color: #0000ff\">if</span> (ctrl.signal.aborted) reject(<span style=\"color: #0000ff\">new</span> ClosedChannelError());\n            queue.push({ value, resolve });\n        });\n    };\n\n    <span style=\"color: #0000ff\">const</span> close = () =&gt; {\n        ctrl.abort();\n    };\n\n    <span style=\"color: #0000ff\">const</span> recv = async <span style=\"color: #0000ff\">function</span>* (signal?: <span style=\"color: #2b91af\">AbortSignal</span>): AsyncIterableIterator&lt;T&gt; {\n        <span style=\"color: #0000ff\">const</span> linked = signal ? link(ctrl.signal, signal) : ctrl.signal;\n        <span style=\"color: #0000ff\">while</span> (<span style=\"color: #0000ff\">true</span>) {\n            <span style=\"color: #0000ff\">if</span> (linked.aborted) {\n                <span style=\"color: #0000ff\">return</span>;\n            }\n            <span style=\"color: #0000ff\">try</span> {\n                <span style=\"color: #0000ff\">const</span> next = await queue.pop({ signal: <span style=\"color: #2b91af\">linked</span> });\n                next.resolve();\n                yield next.value;\n            } <span style=\"color: #0000ff\">catch</span> (_err) {\n                <span style=\"color: #0000ff\">if</span> (linked.aborted) {\n                    <span style=\"color: #0000ff\">return</span>;\n                }\n                <span style=\"color: #0000ff\">throw</span> _err;\n            }\n        }\n    };\n\n    <span style=\"color: #0000ff\">return</span> { send, recv, close, signal: <span style=\"color: #2b91af\">ctrl.signal</span>, closed: <span style=\"color: #2b91af\">abortPromise.promise</span> };\n\n};\n</pre></div>\n\n   \n<p></p>\n<p>\n  One of the most interesting aspects of the JavaScript channel implementation\n  is its similarity to Go channels, particularly when using\n  <code>AsyncIterableIterators</code>. The concept is the same: you can use a\n  <code>for-loop</code><em> </em>to iterate over the channel and wait for the\n  iterator to close, at which point the loop ends. This mirrors the\n  functionality of a Go channel but leverages JavaScript's generators. You can\n  read more about generators\n  <a\n    target=\"_blank\"\n    rel=\"noopener noreferrer nofollow\"\n    href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator\"\n    >here</a\n  >.\n</p>\n<p></p>\n<p>\n  For the WebSocket implementation, I created two channels: one for receiving\n  messages and one for sending messages. This approach allows for different\n  kinds of messages to be transmitted with the strong typing provided by\n  TypeScript.\n</p>\n<p></p>\n<!-- HTML generated using hilite.me -->\n<!-- HTML generated using hilite.me --><div style=\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.0em .0em .0em .0em;padding:.2em .6em;\"><pre style=\"margin: 0; line-height: 125%\"><span style=\"color: #0000ff\">\n    const</span> hosts: <span style=\"color: #2b91af\">string</span>[] = [];\n    <span style=\"color: #0000ff\">const</span> state: <span style=\"color: #2b91af\">ServerConnectionState</span> = {\n        clientId,\n        socket,\n        ch,\n        controller: {\n          link: (host) =&gt; {\n            hosts.push(host);\n            hostToClientId[host] = clientId;\n          },\n        },\n        ongoingRequests: {},\n        apiKeys,\n      };\n      serverStates[state.clientId] = state;\n      \n      <span style=\"color: #0000ff\">try</span> {\n        <span style=\"color: #0000ff\">for</span> await (<span style=\"color: #0000ff\">const</span> message of ch.<span style=\"color: #0000ff\">in</span>.recv(req.signal)) {\n          await handleClientMessage(state, message);\n        }\n      } <span style=\"color: #0000ff\">catch</span> (_err) {\n        <span style=\"color: #008000\">// ignore</span>\n      } <span style=\"color: #0000ff\">finally</span> {\n        <span style=\"color: #0000ff\">delete</span> serverStates[clientId];\n        <span style=\"color: #0000ff\">for</span> (<span style=\"color: #0000ff\">const</span> host of hosts) {\n          <span style=\"color: #0000ff\">if</span> (hostToClientId[host] === clientId) {\n            <span style=\"color: #0000ff\">delete</span> hostToClientId[host];\n          }\n        }\n      }\n      </pre></div>\n      \n\n<p></p>\n<p>These are the steps.</p>\n<p>1. <strong>Server State Initialization:</strong></p>\n<p>\n  - A list of <code>hosts</code> and a <code>ServerConnectionState</code> object\n  <code>state</code> are initialized.\n</p>\n<p>\n  - The <code>controller</code> has a <code>link</code> method that adds hosts\n  to the list and maps them to the <code>clientId</code>.\n</p>\n<p>2. <strong>Handling Incoming Messages:</strong></p>\n<p>\n  - The <code>serverStates</code> global object is updated with the new\n  <code>state</code>.\n</p>\n<p>\n  - A <code>try</code> block listens for messages from the channel and processes\n  them with <code>handleClientMessage</code>.\n</p>\n<p>3. <strong>Cleanup:</strong></p>\n<p>\n  - When the connection ends, the <code>finally</code> block deletes the\n  <code>serverStates</code> entry for the <code>clientId</code>.\n</p>\n<p>\n  - It then iterates over the <code>hosts</code> list and removes any mappings\n  from <code>hostToClientId</code> that match the <code>clientId</code>.\n</p>\n<p>\n  By implementing this approach, I ensured efficient memory management and\n  prevented potential race conditions, maintaining a stable and reliable system.\n</p>\n<p></p>\n<h2>Conclusion</h2>\n<p>\n  Creating Warp involved overcoming several challenges related to data handling,\n  WebSocket management, and state machine implementation. By leveraging channels\n  and state machines, I was able to create an efficient and robust solution.\n  This implementation allows developers to expose their localhost environments\n  through the web, enabling collaboration and testing in a production-like\n  environment with CDN benefits such as image transformation, compression, and\n  asset caching.\n</p>\n<p>\n  I hope this post helps you understand the importance of making your local\n  environment available through the web and inspires you to create your own\n  tools.\n</p>\n<p></p>\n<p>\n  The code is fully open-source and can be found\n  <a\n    target=\"_blank\"\n    rel=\"noopener noreferrer nofollow\"\n    href=\"https://github.com/deco-cx/warp\"\n    >here</a\n  >. Also you can learn how to use warp from\n  <a\n    target=\"_blank\"\n    rel=\"noopener noreferrer nofollow\"\n    href=\"https://deno.com/blog/jsr_open_beta\"\n    >JSR</a\n  >\n  - a new global javascript registry that serves for multiple javascript\n  runtimes.\n</p>\n<p></p>\n<p>\n  <strong\n    ><span style=\"color: rgb(0, 0, 0)\"\n      >Check out how to use this in your personal projects at\n    </span></strong\n  ><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://jsr.io\"\n    ><strong><span style=\"color: rgb(0, 0, 0)\">jsr.io</span></strong></a\n  ><span style=\"color: rgb(236, 236, 236)\">: </span\n  ><a target=\"_new\" rel=\"noreferrer\" href=\"https://jsr.io/@deco/warp\"\n    >Warp on JSR</a\n  ><span style=\"color: rgb(236, 236, 236)\">.</span>\n</p>\n<p></p>\n<p>And see you around,</p>\n<p></p>\n<p>Bye!</p>\n<p></p>\n<p></p>\n",
    "slug": "warp",
    "excerpt": "Warp is a simple tool that allows your locally running HTTP(s) servers to have a public URL, serving as an easy-to-self-host alternative to services like ngrok",
    "title": "How to Make Your Localhost Available Through the Web and Why This Is Important",
    "image": "https://ozksgdmyrqcxcwhnbepg.supabase.co/storage/v1/object/public/assets/10567/ff737e8e-7356-4dc3-843a-93a9a4338b66",
    "date": "2024-05-29"
  }
}