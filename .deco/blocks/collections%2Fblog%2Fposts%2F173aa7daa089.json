{
  "name": "collections/blog/posts/173aa7daa089",
  "__resolveType": "blog/loaders/Blogpost.ts",
  "post": {
    "authors": [
      {
        "name": "Marcos Candeia",
        "email": "marcoscandeia123@gmail.com",
        "jobTitle": "Software Engineer",
        "company": "deco.cx",
        "avatar": "https://ozksgdmyrqcxcwhnbepg.supabase.co/storage/v1/object/public/assets/1527/7286de42-e9c5-4fcb-ae8b-b992eea4b78e"
      }
    ],
    "categories": [
      {
        "name": "Tech",
        "slug": "tech"
      }
    ],
    "content": "<h2>First of all, hello readers!</h2><p></p><p>I'm Marcos Candeia, a 30-year-old software developer with ~11 years of experience (8 professionally). My primary playground is the web, where I craft services and solutions. I'm an open-source contributor, and currently, I'm part of the dynamic team at deco üêÅ, which has inspired me to write this blog post using their tech stack.</p><p></p><p>Today I want to talk about how I have implemented my own version of ngrok and how we use it at <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://deco.cx\">deco.cx</a>.</p><p></p><h2>What is Warp?</h2><p></p><p>Warp is a tool that makes your localhost available through the web, similar to ngrok. However, it offers some unique advantages that can significantly enhance your development workflow.</p><p><img src=\"https://ozksgdmyrqcxcwhnbepg.supabase.co/storage/v1/object/public/assets/10567/8f6c9eba-346a-4989-ab3a-6a500adf74bb\"></p><p>Unlike traditional localhost environments, Warp integrates seamlessly with CDN (Content Delivery Network) services. This integration provides several benefits that make your development environment more \"productive\":</p><p></p><p>1. <strong>Image Transformation (based on the device):</strong> Automatically adjusts images based on the device type, ensuring optimal display and performance across different devices.</p><p>2. <strong>Image Compression and Optimization (e.g., AVIF):</strong> Reduces image sizes and optimizes them for faster loading times without compromising quality.</p><p>3. <strong>Asset Caching:</strong> Improves load times and reduces server load by caching static assets.</p><p></p><h2>Why Making Your Localhost Available Through the Web is Important</h2><p></p><p>1. <strong>Share Your Work Easily:</strong> By making your local environment available on the web, you can easily share your work with colleagues, clients, or anyone else without needing to deploy it publicly. This is particularly useful for getting feedback early in the development process.</p><p>2. <strong>Test Real-world Scenarios:</strong> Testing your application in a real-world environment helps catch issues that might not be apparent in a local setup. By using Warp, you can ensure your application works as expected when accessed over the internet.</p><p>3. <strong>Leverage CDN Benefits:</strong> As mentioned, using Warp allows you to take advantage of CDN features like image transformation, compression, and caching, making your development process more efficient and your application faster.</p><p></p><h2>Show me the code</h2><p></p><h3>Data Handling in Multiple Directions</h3><p>One of the main challenges was handling data in multiple directions. The request body and response body are both streams, which means they can be streamed simultaneously. For example, consider an \"echo\" server that streams the request forward to the server and the server streams it back to the client. To avoid memory overhead and improve performance, I decided to transfer chunks of data instead of buffering the entire body in memory.</p><p></p><h3>Managing WebSocket Callbacks</h3><p>Another challenge was dealing with WebSocket methods, which often use function callbacks. Although I love JavaScript/TypeScript, I dislike callbacks. Drawing from my experience with Go, which handles concurrency elegantly with channels, I created abstractions to transform WebSockets and streams into channels, allowing me to compose them together.</p><p></p><p>Here is an implementation of a generic channel,</p><p></p><pre><code>export const makeChan = &lt;T&gt;(): Channel&lt;T&gt; =&gt; {\n    const queue: Queue&lt;{ value: T, resolve: () =&gt; void }&gt; = new Queue();\n    const ctrl = new AbortController();\n    const abortPromise = Promise.withResolvers&lt;void&gt;();\n    ctrl.signal.onabort = () =&gt; {\n        abortPromise.resolve();\n    }\n\n    const send = (value: T): Promise&lt;void&gt; =&gt; {\n        return new Promise((resolve, reject) =&gt; {\n            if (ctrl.signal.aborted) reject(new ClosedChannelError());\n            queue.push({ value, resolve });\n        });\n    };\n\n    const close = () =&gt; {\n        ctrl.abort();\n    };\n\n    const recv = async function* (signal?: AbortSignal): AsyncIterableIterator&lt;T&gt; {\n        const linked = signal ? link(ctrl.signal, signal) : ctrl.signal;\n        while (true) {\n            if (linked.aborted) {\n                return;\n            }\n            try {\n                const next = await queue.pop({ signal: linked });\n                next.resolve();\n                yield next.value;\n            } catch (_err) {\n                if (linked.aborted) {\n                    return;\n                }\n                throw _err;\n            }\n        }\n    };\n\n    return { send, recv, close, signal: ctrl.signal, closed: abortPromise.promise };\n\n};</code></pre><p></p><p>One of the most interesting aspects of the JavaScript channel implementation is its similarity to Go channels, particularly when using <code>AsyncIterableIterators</code>. The concept is the same: you can use a <code>for-loop</code><em> </em>to iterate over the channel and wait for the iterator to close, at which point the loop ends. This mirrors the functionality of a Go channel but leverages JavaScript's generators. You can read more about generators <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator\">here</a>.</p><p></p><p>For the WebSocket implementation, I created two channels: one for receiving messages and one for sending messages. This approach allows for different kinds of messages to be transmitted with the strong typing provided by TypeScript.</p><p></p><pre><code>export interface DuplexChannel&lt;TSend, TReceive&gt; {\n    in: Channel&lt;TReceive&gt;\n    out: Channel&lt;TSend&gt;\n}\n\nexport const makeWebSocket = &lt;TSend, TReceive&gt;(socket: WebSocket, parse: boolean = true): Promise&lt;DuplexChannel&lt;TSend, TReceive&gt;&gt; =&gt; {\n    const sendChan = makeChan&lt;TSend&gt;();\n    const recvChan = makeChan&lt;TReceive&gt;();\n    const ch = Promise.withResolvers&lt;DuplexChannel&lt;TSend, TReceive&gt;&gt;();\n    socket.onclose = () =&gt; {\n        sendChan.close();\n        recvChan.close();\n    }\n    socket.onerror = (err) =&gt; {\n        socket.close();\n        ch.reject(err);\n    }\n    socket.onmessage = async (msg) =&gt; {\n        let eventData = msg.data;\n        const target = msg?.target;\n        if (\n            target &amp;&amp; \"binaryType\" in target &amp;&amp;\n            target.binaryType === \"blob\" &amp;&amp; typeof eventData === \"object\" &amp;&amp;\n            \"text\" in eventData\n        ) {\n            eventData = await eventData.text();\n        }\n        const message = parse ? JSON.parse(eventData) : eventData;\n        await recvChan.send(message);\n    }\n    socket.onopen = async () =&gt; {\n        ch.resolve({ in: recvChan, out: sendChan });\n        for await (const message of sendChan.recv()) {\n            try {\n                socket.send(parse ? JSON.stringify(message) : message as ArrayBuffer);\n            } catch (_err) {\n                console.error(\"error sending message through socket\", message);\n            }\n        }\n        socket.close();\n    }\n    return ch.promise;\n}</code></pre><p></p><h3><strong>State Machine Implementation</strong></h3><p>I implemented a state machine on both the client and server sides. By leveraging Deno's adherence to web standards, I was able to share code between the two using TypeScript. The state machine processes messages based on their type and delegates them to the appropriate message handler. These handlers use channels to send and receive messages via WebSocket.</p><h3></h3><h4><strong>Unstable HTTP Connections</strong></h4><p>HTTP connections are inherently unstable and can be closed from either side at any time. Handling these disconnections gracefully and ensuring that all resources are properly cleaned up to avoid memory leaks was a significant challenge.</p><p></p><h4><strong>WebSocket Tunneling</strong></h4><p>I added support for tunneling WebSocket connections through the same WebSocket tunnel. This means that not only can you handle simple HTTP requests, but also WebSocket requests themselves. This introduced additional complexity, as I had to ensure that both types of connections could coexist without interfering with each other.</p><p></p><h4><strong>Memory Management</strong></h4><p>Managing memory efficiently was critical, especially given the potential for unterminated requests. I had to carefully design the system to avoid memory leaks and ensure that all resources were properly released when connections were closed.</p><p></p><h2>Conclusion</h2><p>Creating Warp involved overcoming several challenges related to data handling, WebSocket management, and state machine implementation. By leveraging channels and state machines, I was able to create an efficient and robust solution. This implementation allows developers to expose their localhost environments through the web, enabling collaboration and testing in a production-like environment with CDN benefits such as image transformation, compression, and asset caching.</p><p>I hope this post helps you understand the importance of making your local environment available through the web and inspires you to create your own tools.</p><p></p><p>The code is fully open-source and can be found <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/deco-cx/warp\">here</a>. Also you can learn how to use warp from <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://deno.com/blog/jsr_open_beta\">JSR</a> - a new global javascript registry that serves for multiple javascript runtimes.</p><p></p><p><strong><span style=\"color: rgb(0, 0, 0)\">Check out how to use this in your personal projects at </span></strong><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://jsr.io\"><strong><span style=\"color: rgb(0, 0, 0)\">jsr.io</span></strong></a><span style=\"color: rgb(236, 236, 236)\">: </span><a target=\"_new\" rel=\"noreferrer\" href=\"https://jsr.io/@deco/warp\">Warp on JSR</a><span style=\"color: rgb(236, 236, 236)\">.</span></p><p></p><p>And see you around,</p><p></p><p>Bye!</p><p></p><p></p>",
    "slug": "warp",
    "excerpt": "Warp is a simple tool that allows your locally running HTTP(s) servers to have a public URL, serving as an easy-to-self-host alternative to services like ngrok",
    "title": "How to Make Your Localhost Available Through the Web and Why This Is Important",
    "image": "https://ozksgdmyrqcxcwhnbepg.supabase.co/storage/v1/object/public/assets/10567/ff737e8e-7356-4dc3-843a-93a9a4338b66",
    "date": "2024-05-29"
  }
}